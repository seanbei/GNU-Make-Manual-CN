# 如何创建 `Makefile`

通过前面的介绍，我相信你对 `makefile` `已经有了一个大概的了解。makefile` 就是用来告诉 `make` 如何通过读取一个数据集来重编译一个系统所包含的全部信息。有点绕啊，那就直接忽略这条定义吧。

## 3.1 `Makefile` 里包含什么

`Makefile` 包含五样东西：显式规则、隐式规则、变量定义、指令符和注释符。规则、变量和指令符会在后面的章节中详细描述。
- 显式规则：描述如何生成一个或多个文件（就是前面提到的 `target`）。它列出了 `target` 依赖的其他文件（就是前面提到的 `prerequisite`），以及如果生成这些 `target` 的指令动作（就是前面提到的 `recipe`）。可参考第 `4` 章【如何创建`规则`】。
- 隐式规则：描述如何生成一类文件，这些文件（`target`）都依赖与其相同名字的文件，以及其 `recipe`，都是由 `make` 自动推测的，不用写出来。可参考第 `10` 章【使用隐式规则】。
- 变量：在一个地方定义一段字符串，然后在其他地方进行替换使用。参见第 `2.4` 节【如何用变量简化 `makefile`】。
- 指令符：用于 `make` 处理一些特殊的事情，包括：
    - 在一个 `makefile` 中读取另一个 `makefile` 文件，即 `include`。
    - 根据变量的值，来判断是否使用部分 `makefile` 代码，如 `ifeq ifneq`。
    - 定义包含多行的字符串变量，如 `define`。
- 注释符：也就是 `#` 号，`#` 号及其后面整一行的内容都会被注释掉，而且，如果行末带了反斜杠 \，那么下一行也会被注释掉。如果 `#` 号后面什么都不加，那就是一个空行。如果你想在文本中使用 `#` 号，不用作注释符，需要在前面加一个反斜杠（即 `\#`），不然会被当成注释符。注释符可以出现在 `makefile` 中的任何一行上，尽管在某些情况下它们会被特殊处理。

首先，不能在调用变量或函数时使用 `#` 号，这时make 会把 `#` 号当普通字符，而不是注释的开始。如上面例子的 `objects`，如果引用它时写成 `$(#objects)`，`#` 号及其后面的内容并不会被注释掉。

另外，`recipe` 中的 `#` 号会被当作普通字符直接传给 `shell`，然后由 `shell` 自己来确定是否当作注释符来用。

而在指令符 `define` 中，`#` 号在变量定义阶段并不会起作用，直到 `define` 的变量被展开的时候，才会根据上下文来判断是用作注释符还是普通字符。

### 3.1.1 拆分长行

`Makefile` 使用基于行的语法，一个表达式遇到换行符才意味着结束了。`GNU make` 对一个表达式的长度没有任何限制，只取决于电脑内存的大小。

然而，一行的内容如果太长，看起来就很不方便，你只能一直往右拉滚动条才能看到后面的内容，这就必须要换行了。在 `makefile` 里换行非常简单，只需要在你想要换行的地方加上反斜杠（`\`）和换行符（`Enter`）就可以了。我们需要区分“物理行”与“逻辑行”，“物理行”就是一行直接以换行符结尾的，而“逻辑行”由很多反斜杠和换行符结尾的行组成的一个表达式。

反斜杠（`\`）和换行符（`Enter`）组合在一起时，在 `recipe` 的行里面有不一样的效果，这会在第 `5.1.1` 节【拆分 `Recipe` 行】中提到。

除了 `recipe` 的其他地方，反斜杠（`\`）和换行符（`Enter`）会被转化成一个空格符，而它们前后所有的空格（包括中间）都会被忽略。

如果定义了 `.POSIX` 特殊目标，则会稍微修改反斜杠/换行符处理以符合 `POSIX.2`：首先，反斜杠前面的空格不会被删除，第二，连续的反斜杠/换行不会被压缩。

#### 拆分时不留空格
拆分时，如果不希望添加任何空格，有一个巧妙的方法，即在反斜杠 `\` 前加一个 `$` 号：
```Makefile
    var := one$\
            word
```
上面的代码中，`make` 会移除反斜杠和换行符，压缩为一个空格，这相当于：
```Makefile
    var := one$ word
```
然后，`make` 会认为，`$`作为变量引用符，后面紧跟着一个空格，意思就是一个空字符串，于是，上面代码最终相当于：
```Makefile
    var := oneword
```
这样，`oneword` 即使被拆成了两行，`make` 依然会认为它是一个整体。


## 3.2 给 `makefile` 取名

默认情况下，`make` 会按照以下顺序寻找 `makefile`：`GNUmakefile`、`makefile`、`Makefile`。

正常来说，你应该使用 `makefile` 或者 `Makefile` 这两个名字中的一个。（我们建议采用 `Makefile`，因为它出现在目录列表开头的显著位置，就在其他重要文件，如 `README` 的旁边。）而最先去查找的名字 `GNUmakefile` 反而是最不推荐的，如果你的 `makefile` 是专用于 `GNU make` 的，那可以用这个名字，其他版本的 `make` 是无法识别这个名字的。这些版本只会查找 `makefile` 或者 `Makefile`，而不会去找 `GNUmakefile`。

如果 make 没找到上面这些名字，那就不会执行。这时你就需要自己指定目标了，make 会通过自带的隐式规则来执行，参见第 10 章【使用隐式规则】。

如果你不想使用上面的标准名称，而想给 `makefile` 起另外的名字，也是可以的。这时需要使用 `-f` 或 `-file` 可选参数来指定这个文件名。`-f <文件名>` 或 `-file <文件名>` 使得 `make` 把这个文件当作 `makefile` 来使用。如果有多个 `makefile`，那就跟多个 `-f` 或 `-file` 就好。`make` 会把所有的 `makefile` 文件会按顺序串联起来。但是，一旦使用了 `-f` 或 `-file`，原先默认的 `GNUmakefile`，`makefile` 和 `Makefile` 就不会被识别了。


## 3.3 包含其他 `Makefile`

*学过 C 语言的对 `include` 肯定不会陌生，建议提速读完这一节。*

指示符 `include` 会告诉 `make` 暂停读取当前的 `makefile`，转而读取其他 `makefile`，读完之后再继续，格式如下：
```Makefile
    include filenames...
```
`filenames...` 是指可以是一个或多个文件。`filenames` 也是可以是 `shell` 命令。如果 `filenames` 是空的，啥都不会执行，也不会报错。

上面这一行代码，`include` 前面有没有空格都无所谓，都会被忽略。但是，如果前面有 `tab`，那就不行了，因为这一行会被当成 `recipe`。所以，`include` 前面不能带 `tab`（或者更准确的说是 `.RECIPEPREFIX` 的值）。在 `include` 与 `filename` 之间必须有空格，多个 `filename` 之间也得有空格。注释符 `#` 号在行尾可以使用。如果 `filename` 文件名包含了变量或者函数名，它们会被展开。参见第 `6` 章【如何使用变量】。

例如，如果你有三个 `.mk` 文件：`a.mk`、`b.mk` 和 `c.mk`，`$(bar)` 扩展为 `bish bash`，于是以下代码：
```Makefile
    include foo *.mk $(bar)
```
等同于：
```Makefile
    include foo a.mk b.mk c.mk bish bash
```

make 是这么处理 include 指示符的。首先，读取 make 查找到的或指定的 makefile，读取过程中遇到 include，make 就会依次读取 include 后面的文件，全部读取完毕，make 回到最开始的 makefile 接着往下读取。

使用 include 的第一个场景是，处在不同目录下的 makefile 需要使用同一套变量或规则。这个好处显而易见，后面对变量或规则不管是新增还是修改，只要在一个 makefile 里改就行，不会造成遗漏。

另外一个场景是，你想要从源文件自动生成依赖文件，这些依赖项就可以单独放在一个文件中，然后 include 到主 makefile 中。这通常比常规做法更简洁。常规做法是将依赖项放到同一个 makefile 中，如前面我们最开始的例子。

如果指定的文件名不是以斜杠 / 开始，

## 3.4 MAKEFILES 变量


## 3.5 How Makefiles Are Remade


## 3.6 Makefile 重载

*学过编程的人可能听过`重载函数`，重载一个函数，意思就是用一个新的函数来替换原有的函数，函数名保持不变。在 makefile 中也可以使用重载。*

有时候，会遇到你要写的 makefile 跟之前的某一个 makefile 内容很相似，这个时候，就可以将之前的那个 include 到要写的这个里面，然后添加不同的目标或变量。但是，如果不想用原先 makefile 中目标的生成规则，而是想重新为这个目标定义一个规则，怎么办呢？是不是可以像重载函数那样，直接写上去就行了呢？并不能。因为两个 makefile 给同一个目标定义不同的 recipe 是无效的。我们有另外一种方式。

在要新写的 makefile 中

例如，之前已经存在的 makefile 叫 Makefile，它定义了如何来生成目标 foo（以及其他目标）。新写的 makefile 叫 GNUmakefile，里面这么写：
```Makefile
    foo:
            frobnicate > foo
    %: force
            @$(MAKE) -f Makfile $@
    force: ;
```

如果运行 make foo，make 会在 GNUmakefile 中找到它，发现需要执行 recipe：frobnicate > foo。如果运行 make bar，由于 GNUmakefile 中并没有目标 bar，所以会使用模式匹配规则：make -f Makefile bar。这时，make 就会去 Makefile 中寻找目标 bar，如果有，就会执行。对于 GNUmakefile 没有定义的目标，make 都会去 Makefile 里面找。